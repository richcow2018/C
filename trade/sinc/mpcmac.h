/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCABORT													*/
/*																			*/
/* ＜機能概要＞  アボート処理を行う											*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     詳細情報													*/
/*	   P2	     任意値１ 													*/
/*	   P3	     モジュールＩＤ（拡張モジュールＩＤの下２桁）				*/
/*	   P4	     任意値２ 													*/
/*																			*/
/*--------------------------------------------------------------------------*/
/* ＜ソース修正者＞					 本田信幸								*/
/* ＜ソース正年月日及び修正ＩＤ＞	 ２００２年１２月０４日（M01）			*/
/*	Linux化による修正														*/
/*		「C_OPEN()を	→	C_OPEN2()へ変更」								*/
/*		「C_CONN()を	→	C_CONN2()へ変更」								*/
/*		「C_DCONN()を	→	C_DCONN2()へ変更」								*/
/*		「C_IREADD()を	→	C_IREADD2()へ変更」								*/
/*		「C_IWRITD()を	→	C_IWRITD2()へ変更」								*/
/*		「C_IIOCTL()を	→	C_IIOCTL2()へ変更」								*/
/*																			*/
/****************************************************************************/
#define MPCPABT(P1, P2, P3, P4) 		/* アボート処理 					*/\
	MCS_ABEX(MID_EX + P3, P1, P2, P4)	/* プロセスアボートマクロ			*/
/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCACTVP													*/
/*																			*/
/* ＜機能概要＞  回線制御配下の論理パス制御に対してパスＡＣＴＩＶＥ通知ＩＲ */
/*				 Ｂを登録する												*/
/* ＜仮引数＞																*/
/*	   P1	     パス制御先頭アドレス										*/
/*	   P2	     パス数 													*/
/****************************************************************************/
#define MPCACTVP(P1, P2)				/* パスＡＣＴＩＶＥ通知発行処理 	*/\
{																			  \
	unsigned short	i;					/* パス数インデックス				*/\
	MPCIRB0  *actvpirb; 				/* パスＡＣＴＩＶＥ通知ＩＲＢポイン */\
										/* タ								*/\
	long	  ctxtp;					/* パスＡＣＴＩＶＥ通知ＩＲＢを発信 */\
										/* するコンテキストアドレス 		*/\
	ctxtp = P1; 						/* コンテキストアドレスに最初に発信 */\
										/* するアドレスを設定する			*/\
	for( i = 0; i < P2; i++ )			/* パス数分繰り返す 				*/\
	{																		  \
		actvpirb = (MPCIRB0 *)mcs_z200(TYPN);								  \
										/* パスＡＣＴＩＶＥ通知ＩＲＢ確保	*/\
		MCS_IREQ(actvpirb, _IR_PACTP, _SIR_NULL, _ML_PACTP, ctxtp); 		  \
										/* パスＡＣＴＩＶＥ通知ＩＲＢ発信	*/\
		ctxtp += sizeof(MPCPMB);		/* コンテキストアドレスに次に発信す */\
										/* るアドレスを設定する 			*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCCANRD													*/
/*																			*/
/* ＜機能概要＞  メッセージを格納するＩＲＢをキューターミナルからデキューし */
/*				 応答する。デキューしたＩＲＢは解放する 					*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     キューポインタ 											*/
/*	   P2	     キャンセルして応答するメッセージ数 						*/
/*	   P3		 コンテキストアドレス										*/
/*	   P4	     異常要因													*/
/****************************************************************************/
#define MPCCANRD(P1, P2, P3, P4)		/* 電文受信キャンセル発行処理		*/\
{																			  \
	MCSIRB *tred_irb;					/* 電文受信要求通知ＩＲＢ			*/\
	unsigned char	cnt;				/* カウンタ				 			*/\
	cnt = 0;							/* カウンタ←０						*/\
	while( cnt < P2 )					/* カウンタ＜キャンセル応答するメッ	*/\
										/* セージ数の場合 					*/\
	{																		  \
		MCS_HDEQ(P1, tred_irb);												  \
										/* ＩＲＢキューターミナルからＩＲＢ */\
										/* をデキュー						*/\
		if( ((MPCIRB0 *)tred_irb)->irblinkp )								  \
										/* システムコール完了ＩＲＢとリンク */\
										/* している場合 					*/\
		{																	  \
			mcs_z700(((MPCIRB0 *)tred_irb)->irblinkp);						  \
										/* システムコールをキャンセルする	*/\
		}																	  \
		MPCMEDT3(((MPCIRB0 *)tred_irb)->msgp, mpccpt, -1);					  \
										/* 応答編集処理３					*/\
		mpc00001((MPCRQMSG *)((MPCIRB0 *)tred_irb)->msgp, P4,				  \
			((MPCIRB0 *)tred_irb)->msglen);									  \
										/* 応答処理							*/\
		mcs_z300(tred_irb); 			/* 電文受信要求通知IRB解放			*/\
		cnt++;							/* カウンタインクリメント			*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCDACTC													*/
/*																			*/
/* ＜機能概要＞  該当論理パス配下のコネクション制御に対して、コネクションＤ */
/*				 ＥＡＣＴ通知を発行する 									*/
/* ＜仮引数＞																*/
/*	   P1	     コネクションコンテキストＱＴポインタ						*/
/*	   P2	     コネクションをＤＥＡＣＴする要因コード 					*/
/*	   P3	     障害要因コード 											*/
/****************************************************************************/
#define MPCDACTC(P1, P2, P3)			/* コネクションＤＥＡＣＴ通知処理	*/\
{																			  \
	MPCCMB	*wctxtpt;					/* コネクション制御コンテキストアド	*/\
										/* レス								*/\
	MPCIRB0 *irbp;						/* ＩＲＢポインタ					*/\
	wctxtpt=(MPCCMB *)((XQT *)P1)->xqt[0];									  \
										/* キューコンテキストアドレス取得	*/\
	while( wctxtpt )					/* コンテキストアドレスの判定		*/\
	{																		  \
		mcs_z900(wctxtpt);				/* コネクション制御コンテキストのバ */\
										/* ッファ取得リトライの取り消し 	*/\
		irbp = (MPCIRB0 *)mcs_z200(TYPN);									  \
										/* ＩＲＢ確保						*/\
		irbp->deactsts = P3;			/* 障害要因の設定					*/\
		MCS_IREQ(irbp, _IR_CCDEA, P2, _ML_CCDEA, wctxtpt);					  \
										/* コネクションＤＥＡＣＴ通知ＩＲＢ	*/\
										/* 発信								*/\
		wctxtpt=(MPCCMB *)wctxtpt->ctxtqt.xqlink[1];						  \
										/* 次にキューリンクしているコンテキ	*/\
										/* ストアドレス取得					*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCDACTP													*/
/*																			*/
/* ＜機能概要＞  回線制御配下の論理パス制御に対してパスＤＥＡＣＴ通知ＩＲＢ */
/*				 を登録する 												*/
/* ＜仮引数＞																*/
/*	   P1	     パス制御先頭アドレス										*/
/*	   P2	     パス数 													*/
/*	   P3		 障害情報（異常要因コード） 								*/
/*	   P4	     未回収パス数 												*/
/****************************************************************************/
#define MPCDACTP(P1, P2, P3, P4)		/* パスＤＥＡＣＴ通知発行処理		*/\
{																			  \
	unsigned short	i;					/* カウンタ							*/\
	MPCIRB0  *dactpirb; 				/* パスＤＥＡＣＴ通知ＩＲＢポインタ */\
	long	  ctxtp;					/* パスＤＥＡＣＴ通知ＩＲＢを発信す */\
										/* るコンテキストアドレス			*/\
	ctxtp = P1; 						/* コンテキストアドレスに最初に発信 */\
										/* するアドレスを設定する			*/\
	i = 0;								/* カウンタ←０						*/\
	while( i < P2 )						/* カウンタ＜パス数 				*/\
	{																		  \
		if( ((MPCPMB *)ctxtp)->pdacirbp == 0 )								  \
										/* パス制御コンテキストのパスＤＥＡ */\
										/* ＣＴ通知ＩＲＢ退避域 ＝ ０		*/\
		{																	  \
			dactpirb = (MPCIRB0 *)mcs_z200(TYPN);							  \
										/* パスＤＥＡＣＴ通知ＩＲＢ確保 	*/\
			dactpirb->deactsts = P3;	/* 障害要因設定 					*/\
			MCS_IREQ(dactpirb, _IR_PDACP, _SIR_NULL, _ML_PDACP, ctxtp); 	  \
										/* パスＤＥＡＣＴ通知ＩＲＢ発信 	*/\
			P4++;						/* 未回収パス数インクリメント		*/\
		}																	  \
		ctxtp += sizeof(MPCPMB);		/* 次に発信するコンテキストアドレス */\
										/* を設定する 						*/\
		i++;							/* カウンタインクリメント			*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCENDDC													*/
/*																			*/
/* ＜機能概要＞  論理パス制御に対してコネクションＤＥＡＣＴ完了通知を登録す */
/*				 る 														*/
/* ＜仮引数＞																*/
/*	   P1	     パス制御コンテキストアドレス								*/
/*	   P2	     コネクションＤＥＡＣＴ完了通知ＩＲＢポインタ				*/
/*	   P3	     コネクションＤＥＡＣＴ通知ＩＲＢのサブＩＲコード			*/
/*	   P4	     コネクション制御コンテキストアドレス						*/
/*																			*/
/****************************************************************************/
#define MPCENDDC(P1, P2, P3, P4)		/* コネクションＤＥＡＣＴ完了通知処 */\
										/* 理								*/\
{																			  \
	((MPCIRB0 *)P2)->srctxtp = (long)P4;/* コネクション制御コンテキストア	*/\
										/* ドレス							*/\
	MCS_IREQ(P2, _IR_PCDCT, P3, _ML_PCDCT, P1); 							  \
										/* コネクションＤＥＡＣＴ完了通知Ｉ */\
										/* ＲＢ発信 						*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCFREMQ													*/
/*																			*/
/* ＜機能概要＞  ＩＲＢキューに格納しているメッセージおよびＩＲＢを解放する */
/* ＜仮引数＞																*/
/*	   P1	     キューポインタ 											*/
/*	   P2	     解放するメッセージ数										*/
/*	   P3	     拡張モジュールＩＤ（下２桁）								*/
/*																			*/
/****************************************************************************/
#define MPCFREMQ(P1, P2, P3)			/* メッセージキュー解放処理 		*/\
{																			  \
	unsigned short	i;					/* 解放するメッセージ数のカウンタ	*/\
	MCSIRB *irbp;						/* 解放するメッセージを持つＩＲＢ	*/\
	i = (unsigned short)P2; 			/* 解放するメッセージ数設定 		*/\
	while( i )							/* カウンタ数分の繰り返す			*/\
	{																		  \
		MCS_HDEQ(P1, irbp); 			/* メッセージをもつＩＲＢをデキュー */\
		MPCMFREE(((MPCIRB0 *)irbp)->msgp, P3,								  \
			AD_MCOM1(((MPCIRB0 *)irbp)->msgp) );							  \
										/* メッセージ解放					*/\
		mcs_z300(irbp); 				/* ＩＲＢ解放						*/\
		i--;							/* カウンタデクリメント				*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCIDXSO													*/
/*																			*/
/* ＜機能概要＞  完了したＳＥＴＯＰＴ完了ＩＲＢのサブＩＲコードからオプショ */
/*				 ン種別を判定して、該当するオプション設定要求退避域のインデ */
/*				 ックスを返す												*/
/* ＜仮引数＞																*/
/*	   P1	     オプション種別					 							*/
/*	   P2	     オプション設定要求退避域インデックス						*/
/****************************************************************************/
#define MPCIDXSO(P1, P2)				/* オプション設定要求退避域インデッ	*/\
										/* クス算出							*/\
{																			  \
	switch( P1 ) 						/* オプション種別を判定する         */\
	{																		  \
		case SOKEEPAL:					/* コネクション保存オプション		*/\
			P2 = OPTCNSVP;				/* ｵﾌﾟｼｮﾝ設定要求（ｺﾈｸｼｮﾝ保存ｵﾌﾟｼｮﾝ	*/\
										/* )退避域設定						*/\
			break;															  \
		case SODNTRTE:					/* 経路選択オプション				*/\
			P2 = OPTROUTP;				/* ｵﾌﾟｼｮﾝ設定要求（経路選択ｵﾌﾟｼｮﾝ)	*/\
										/* 退避域設定						*/\
			break;															  \
		case SOLINGER:					/* リンガーオプション				*/\
			P2 = OPTLINGP;				/* ｵﾌﾟｼｮﾝ設定要求（ﾘﾝｶﾞｰｵﾌﾟｼｮﾝ)退避	*/\
										/* 域設定							*/\
			break;															  \
		case SOOOBINL:					/* 緊急データオプション 			*/\
			P2 = OPTOOBDP;				/* ｵﾌﾟｼｮﾝ設定要求（緊急ﾃﾞｰﾀｵﾌﾟｼｮﾝ)	*/\
										/* 退避域設定						*/\
			break;															  \
		case SOSNDBUF:					/* 送信バッファオプション			*/\
			P2 = OPTSBUFP;				/* ｵﾌﾟｼｮﾝ設定要求（送信ﾊﾞｯﾌｧｵﾌﾟｼｮﾝ)	*/\
										/* 退避域設定						*/\
			break;															  \
		case SORCVBUF:					/* 受信バッファオプション			*/\
			P2 = OPTRBUFP;				/* ｵﾌﾟｼｮﾝ設定要求（受信ﾊﾞｯﾌｧｵﾌﾟｼｮﾝ)	*/\
										/* 退避域設定						*/\
			break;															  \
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCMEDT1													*/
/*																			*/
/* ＜機能概要＞  応答コマンドのローカルインタネットアドレス、ローカルポート */
/*				 番号のデータ設定を行う 									*/
/* ＜仮引数＞																*/
/*	   P1	     応答メッセージポインタ 									*/
/*	   P2	     論理パス制御コンテキストアドレス							*/
/****************************************************************************/
#define MPCMEDT1(P1, P2)				/* 応答編集処理１					*/\
{																			  \
	((MPCRQMSG *)P1)->usr.mpcolipa = P2->lipaddr;				  			  \
										/* ローカルインタネットアドレス編集 */\
	((MPCRQMSG *)P1)->usr.mpcolpon = P2->lport; 				  			  \
										/* ローカルポート番号編集			*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCMEDT2													*/
/*																			*/
/* ＜機能概要＞  応答コマンドのコネクション識別子、ローカルインタネットアド */
/*				 レス、ローカルポート番号、リモートインタネットアドレス、リ */
/*				 モートポート番号のデータ設定を行う 						*/
/* ＜仮引数＞																*/
/*	   P1	     応答メッセージポインタ 									*/
/*	   P2	     コネクション制御コンテキストアドレス						*/
/****************************************************************************/
#define MPCMEDT2(P1, P2)				/* 応答編集処理２					*/\
{																			  \
	MPCPMB	*pmbp;						/* パス制御コンテキストアドレス 	*/\
	pmbp = (MPCPMB *)P2->pathctxa;		/* パス制御コンテキストアドレス 取得*/\
	((MPCRQMSG *)P1)->usr.mpcocnnd = (long)P2;								  \
										/* コネクション識別子 編集			*/\
	((MPCRQMSG *)P1)->usr.mpcolipa = pmbp->lipaddr; 						  \
										/* ローカルインタネットアドレス 編集*/\
	((MPCRQMSG *)P1)->usr.mpcolpon = pmbp->lport;							  \
										/* ローカルポート番号 編集			*/\
	((MPCRQMSG *)P1)->usr.mpcoripa = P2->ripaddr;							  \
										/* リモートインタネットアドレス 編集*/\
	((MPCRQMSG *)P1)->usr.mpcorpon = P2->rport; 							  \
										/* リモートポート番号 編集			*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCMEDT3													*/
/*																			*/
/* ＜機能概要＞  応答コマンドのコネクション識別子、ローカルインタネットアド */
/*				 レス、ローカルポート番号、リモートインタネットアドレス、リ */
/*				 モートポート番号、コネクション状態、データ長のデータ設定を */
/*				 行う														*/
/* ＜仮引数＞																*/
/*	   P1	     応答メッセージポインタ 									*/
/*	   P2	     コネクション制御コンテキストアドレス						*/
/*	   P3	     ｏｓｉｒｅａｄｄのリザルト値（データ長）					*/
/****************************************************************************/
#define MPCMEDT3(P1, P2, P3)			/* 応答編集処理３					*/\
{																			  \
	MPCPMB	*pmbp;						/* パス制御コンテキストアドレス 	*/\
	pmbp = (MPCPMB *)P2->pathctxa;		/* パス制御コンテキストアドレス 取得*/\
	((MPCMSGRW *)P1)->usr.mpcocnnd = (long)P2;								  \
										/* コネクション識別子 編集			*/\
	((MPCMSGRW *)P1)->usr.mpcolipa = pmbp->lipaddr; 						  \
										/* ローカルインタネットアドレス 編集*/\
	((MPCMSGRW *)P1)->usr.mpcolpon = pmbp->lport;							  \
										/* ローカルポート番号 編集			*/\
	((MPCMSGRW *)P1)->usr.mpcoripa = P2->ripaddr;							  \
										/* リモートインタネットアドレス 編集*/\
	((MPCMSGRW *)P1)->usr.mpcorpon = P2->rport; 							  \
										/* リモートポート番号 編集			*/\
	((MPCMSGRW *)P1)->usr.mpcopthf =										  \
				( BITCHECK(mpccpt->flags, FLGCFIN) ? FLGRVFIN : 0x00 ); 	  \
										/* コネクション状態 設定			*/\
	((MPCMSGRW *)P1)->usr.mpcodtsz = ((long)P3 >= 0) ?						  \
		 (short)P3 : ((MPCMSGRW *)P1)->usr.mpcodtsz ;						  \
										/* データ長 設定					*/\
}
/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCMFREE													*/
/*																			*/
/* ＜機能概要＞  プールバッファの解放を行う 								*/
/* ＜仮引数＞																*/
/*	   P1		 プールバッファポインタ 									*/
/*	   P2	     拡張モジュールＩＤ（下２桁）								*/
/*	   P3	     詳細情報の下３オクテットに指定する値						*/
/****************************************************************************/
#define MPCMFREE(P1, P2, P3)			/* バッファ解放 					*/\
{																			  \
	long	ret;						/* ｍｏ＿ｆｒｂｆ（）返却値 		*/\
	long	abt_dtil;					/* アボート詳細情報					*/\
	abt_dtil = P3;						/* アボート詳細情報設定				*/\
	DBGPRINT2_MPCMFREE("mo_frbf(%08x)\n", P1);								  \
	ret = mo_frbf(P1);					/* 領域解放 						*/\
	if( ret != 0 )						/* 返却値異常の場合					*/\
	{																		  \
		MPCPABT(ABTOFBF0, abt_dtil, P2, ret);								  \
										/* アボート処理（サービスコール異常	*/\
										/* (mo_frbf)）						*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCMGET													*/
/*																			*/
/* ＜機能概要＞  サービスコール（ｍｏ＿ｇｔｂｆ）を使用してプールバッファを */
/*				 確保し、サービスコール（ｍｏ＿ｎｃｌｒ）を使用して、確保し */
/*				 たプールバッファを初期化（０クリア）する					*/
/* ＜仮引数＞																*/
/*	   P1	     バッファポインタ											*/
/*	   P2	     バッファサイズ 											*/
/*	   P3		 バッファタイプ 											*/
/*	   P4	     拡張モジュールＩＤ（下２桁）								*/
/*	   P5	     アボート時の詳細情報										*/
/****************************************************************************/
#define MPCMGET(P1, P2, P3, P4, P5) 	/* バッファ取得 					*/\
{																			  \
	long	ret;						/* サービスコール返却値 			*/\
    DP_SVCMACRO_PARAM(1, "BufferPointer", (long)P1);                          \
    DP_SVCMACRO_PARAM(2, "BufferSize", (long)P2);                             \
    DP_SVCMACRO_PARAM(3, "BufferType", (long)P3);                             \
    DP_SVCMACRO_PARAM(4, "MID-EX", (long)P4);                                 \
    DP_SVCMACRO_PARAM(5, "AbortDetail3", (long)P5);                           \
	DP_SVCCALL_NAME("mo_gabf");                                               \
	ret = mo_gabf(P3, P2, &P1);												  \
										/* 領域確保 						*/\
										/* 					  94'07/22(M02) */\
	BP_RETURN_MOGABF(ret, &ret);		/*									*/\
	if( ret < (long)P2 ) 				/* 返却値異常の場合					*/\
	{																		  \
		MPCPABT(ABTOGABF, P5, P4, ret); /* アボート処理（サービスコール異常 */\
										/* (mo_gabf)）						*/\
	}																		  \
    DP_SVCMACRO_PARAM(1, "BufferPointer", (long)P1);                          \
    DP_SVCMACRO_PARAM(2, "BufferSize", (long)P2);                             \
    DP_SVCMACRO_PARAM(3, "BufferType", (long)P3);                             \
    DP_SVCMACRO_PARAM(4, "MID-EX", (long)P4);                                 \
    DP_SVCMACRO_PARAM(5, "AbortDetail3", (long)P5);                           \
	DP_SVCCALL_NAME("mc_nclr");                                               \
	ret = mc_nclr(P1, P2);				/* 領域０クリア						*/\
	BP_RETURN_MCNCLR(ret, &ret);		/*									*/\
	if( ret != MCNMAL )					/* 返却値異常の場合					*/\
	{																		  \
		MPCPABT(ABTONCLR, P5, P4, ret); /* アボート処理（サービスコール異常 */\
										/* (mo_nclr)）						*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQABOT													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＡＢＯＲＴ）システムコールを発行し、 	*/
/*				 ＡＢＯＲＴ完了ＩＲＢを登録する 							*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＡＢＯＲＴ完了ＩＲＢポインタ								*/
/****************************************************************************/
#define MPCQABOT(P1, P2, P3)			/* ＡＢＯＲＴ発行処理				*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP0 *arg_abot; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_abot = (ARG_TYP0 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_abot->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_abot->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	BP_CALL_ABORT(sizeof(ARG_TYP0), arg_abot);								  \
	DELAY_ABORT(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_ABORT, arg_abot, sizeof(ARG_TYP0));  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M02	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLABOT, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CABOT ,_SIR_NULL, _ML_CABOT, P2, rd); 				  \
										/* ＡＢＯＲＴ完了ＩＲＢ発信 		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQACPT													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＡＣＣＥＰＴ）システムコールを発行し、	*/
/*				 ＡＣＣＥＰＴ完了ＩＲＢを登録する							*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＡＣＣＥＰＴ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQACPT(P1, P2, P3)			/* ＡＣＣＥＰＴ発行処理 			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_CONN *arg_acpt; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_acpt = (ARG_CONN *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_acpt->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_acpt->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	DELAY_ACCEPT(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_ACCEPT, arg_acpt, sizeof(ARG_CONN)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLACPT, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PACPT ,_SIR_NULL, _ML_PACPT, P2, rd); 				  \
										/* ＡＣＣＥＰＴ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQASY0													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（非同期通知要求）システムコールを発行し、 */
/*				 非同期通知要求完了ＩＲＢ（パス制御コンテキストあて）を登録 */
/*				 する														*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 非同期通知要求完了ＩＲＢポインタ							*/
/****************************************************************************/
#define MPCQASY0(P1, P2, P3)			/* 非同期通知要求発行処理０ 		*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_ASYN *arg_asy0; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_asy0 = (ARG_ASYN *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_asy0->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	DELAY_ASYNC0(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_ASYNC, arg_asy0, sizeof(ARG_ASYN));  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLASYN, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PASY0 ,_SIR_NULL, _ML_PASY0, P2, rd); 				  \
										/* 非同期通知要求完了ＩＲＢ発信 	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQASY1													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（非同期通知要求）システムコールを発行し、 */
/*				 非同期通知要求完了ＩＲＢ（コネクション制御コンテキストあて */
/*				 ）を登録する												*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 非同期通知要求完了ＩＲＢポインタ							*/
/****************************************************************************/
#define MPCQASY1(P1, P2, P3)			/* 非同期通知要求発行処理１ 		*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_ASYN *arg_asy1; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_asy1 = (ARG_ASYN *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_asy1->sesno = P2->lsno;			/* ローカルセッション番号設定		*/\
	DELAY_ASYNC1(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_ASYNC, arg_asy1, sizeof(ARG_ASYN));  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLASYN, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CASY1 ,_SIR_NULL, _ML_CASY1, P2, rd); 				  \
										/* 非同期通知要求完了ＩＲＢ発信 	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQATCH													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＡＴＴＡＣＨ）システムコールを発行し、	*/
/*				 ＡＴＴＡＣＨ完了ＩＲＢを登録する							*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＡＴＴＡＣＨ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQATCH(P1, P2, P3)			/* ＡＴＴＡＣＨ発行処理 			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP0 *arg_atch; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_atch = (ARG_TYP0 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_atch->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	DELAY_ATTACH(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_ATTACH, arg_atch, sizeof(ARG_TYP0)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLATCH, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PATCH ,_SIR_NULL, _ML_PATCH, P2, rd); 				  \
										/* ＡＴＴＡＣＨ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQBIND													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＢＩＮＤ）システムコールを発行し、		*/
/*				 ＢＩＮＤ完了ＩＲＢを登録する								*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＢＩＮＤ完了ＩＲＢポインタ 								*/
/****************************************************************************/
#define MPCQBIND(P1, P2, P3)			/* ＢＩＮＤ発行処理 				*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP1 *arg_bind; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_bind = (ARG_TYP1 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_bind->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_bind->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_bind->a_family = AF_INET;		/* アドレスファミリー識別子設定 	*/\
	arg_bind->l_port = P2->lport;		/* ローカルポート番号設定			*/\
	arg_bind->l_ipaddr = P2->lipaddr;	/* ローカルアドレス設定 			*/\
	arg_bind->reserve0[0] = 0L; 		/* リザーブに０設定 				*/\
	arg_bind->reserve0[1] = 0L; 		/* リザーブに０設定 				*/\
	DELAY_BIND(30);						/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_BIND, arg_bind, sizeof(ARG_TYP1));   \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLBIND, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PBIND ,_SIR_NULL, _ML_PBIND, P2, rd); 				  \
										/* ＢＩＮＤ完了ＩＲＢ発信			*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQCONN													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＣＯＮＮＥＣＴ）システムコールを発行し、 */
/*				 ＣＯＮＮＥＣＴ完了ＩＲＢを登録する 						*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＣＯＮＮＥＣＴ完了ＩＲＢポインタ							*/
/****************************************************************************/
#define MPCQCONN(P1, P2, P3)			/* ＣＯＮＮＥＣＴ発行処理			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_CONN *arg_conn; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_conn = (ARG_CONN *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_conn->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_conn->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_conn->a_family = AF_INET;		/* アドレスファミリー識別子設定 	*/\
	arg_conn->r_port = P2->rport;		/* リモートポート番号設定			*/\
	arg_conn->r_ipaddr = P2->ripaddr;	/* リモートアドレス設定 			*/\
	arg_conn->reserve0[0] = 0L; 		/* リザーブに０設定 				*/\
	arg_conn->reserve0[1] = 0L; 		/* リザーブに０設定 				*/\
	DELAY_CONNECT(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_CONNCT , arg_conn,					  \
		sizeof(ARG_CONN));													  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLCONN, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CCONN ,_SIR_NULL, _ML_CCONN, P2, rd); 				  \
										/* ＣＯＮＮＥＣＴ完了ＩＲＢ発信 	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQDCH0													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＤＥＴＡＣＨ）システムコールを発行し、	*/
/*				 ＤＥＴＡＣＨ完了ＩＲＢ（パス制御コンテキストあて）を登録	*/
/*				 する														*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＤＥＴＡＣＨ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQDCH0(P1, P2, P3)			/* ＤＥＴＡＣＨ発行処理０			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP0 *arg_dch0; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_dch0 = (ARG_TYP0 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_dch0->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_dch0->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	DELAY_DETACH0(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_DETACH, arg_dch0, sizeof(ARG_TYP0)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLDECH, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PDECH ,_SIR_NULL, _ML_PDECH, P2, rd); 				  \
										/* ＤＥＴＡＣＨ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQDCH1													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＤＥＴＡＣＨ）システムコールを発行し、	*/
/*				 ＤＥＴＡＣＨ完了ＩＲＢ（コネクション制御コンテキストあて） */
/*				 を登録する 												*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＤＥＴＡＣＨ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQDCH1(P1, P2, P3)			/* ＤＥＴＡＣＨ発行処理１			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP0 *arg_dch1; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_dch1 = (ARG_TYP0 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_dch1->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_dch1->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	DELAY_DETACH1(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_DETACH, arg_dch1, sizeof(ARG_TYP0)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLDECH, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CDECH ,_SIR_NULL, _ML_CDECH, P2, rd); 				  \
										/* ＤＥＴＡＣＨ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQDCON													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＤＩＳＣＯＮＮＥＣＴ）システムコールを発 */
/*				 行し、ＤＩＳＣＯＮＥＣＴ完了ＩＲＢを登録する				*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＤＩＳＣＯＮＮＥＣＴ完了ＩＲＢポインタ 					*/
/****************************************************************************/
#define MPCQDCON(P1, P2, P3)			/* ＤＩＳＣＯＮＮＥＣＴ発行処理 	*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_TYP0 *arg_dcon; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_dcon = (ARG_TYP0 *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_dcon->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_dcon->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	DELAY_DISCONNECT(30);				/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_DISCON, arg_dcon, sizeof(ARG_TYP0)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLDCON, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CDCON ,_SIR_NULL, _ML_CDCON, P2, rd); 				  \
										/* ＤＩＳＣＯＮＮＥＣＴ完了IRB発信	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQFINF													*/
/*																			*/
/* ＜機能概要＞  ｏｓｇｆｉｎｆシステムコールを発行し、特殊ファイル情報を	*/
/*				 取得する													*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2		 ファイルディスクリプタ 									*/
/*	   P3	     特殊ファイル情報格納域 									*/
/****************************************************************************/
#define MPCQFINF(P1, P2, P3)			/* 特殊ファイル情報取得 			*/\
{																			  \
	long	ret;						/* 返却値							*/\
	BP_ARGDUMP_OSGFINF(sizeof(struct osf_info), &P3,						  \
		"TokusyuFileJyouhouIkiDump osgfinf mae\n");							  \
	ret = C_GFINF(P2, OSFGFALL, &P3, sizeof(struct osf_info));				  \
										/* ｏｓｇｆｉｎｆ発行			M01 */\
	BP_ARGDUMP_OSGFINF(sizeof(struct osf_info), &P3,						  \
		"TokusyuFileJyouhouIkiDump osgfinf ato\n");							  \
	BP_RETURN_OSGFINF(ret);	  												  \
	if( ret < sizeof(struct osf_info) )	/* 返却値異常						*/\
	{																		  \
		MPCPABT(ABTLFINF, AD_RESLT, P1, ret);								  \
										/* アボート処理（返却値異常）		*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQLIST													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＬＩＳＴＥＮ）システムコールを発行し、	*/
/*				 ＬＩＳＴＥＮ完了ＩＲＢを登録する							*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＬＩＳＴＥＮ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQLIST(P1, P2, P3)			/* ＬＩＳＴＥＮ発行処理 			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_LIST *arg_list; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_list = (ARG_LIST *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_list->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_list->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_list->backlog = SOMAXCONN;		/* 最大接続待ち保留数設定			*/\
	arg_list->reserve0 = 0; 			/* リザーブに０設定 				*/\
	DELAY_LISTEN(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_LISTEN, arg_list, sizeof(ARG_LIST)); \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLLIST, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_PLISN ,_SIR_NULL, _ML_PLISN, P2, rd); 				  \
										/* ＬＩＳＴＥＮ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQOPEN													*/
/*																			*/
/* ＜機能概要＞  ｏｓｏｐｅｎシステムコールを発行し、特殊ファイルをオープン */
/*				 する														*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2		 ファイルディスクリプタ 									*/
/****************************************************************************/
#define MPCQOPEN(P1, P2)				/* 特殊ファイルオープン 			*/\
{																			  \
	long	ret;						/* 返却値							*/\
	ret = C_OPEN2(P2, 6L, 1L, 1L, 1L, 1L);									  \
										/*								M01	*/\
										/* ｏｓｏｐｅｎ発行 				*/\
	BP_RETURN_OSOPEN(ret);				/* デバック（ブレークポイント）		*/\
	if( ret < 0 )						/* 返却値異常						*/\
	{																		  \
		MPCPABT(ABTLOPEN, AD_RESLT, P1, ret);								  \
										/* アボート処理（返却値異常）		*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQOSCN													*/
/*																			*/
/* ＜機能概要＞  ｏｓｃｏｎｎシステムコールを発行し、プロセスと特殊ファイル */
/*				 との連結を行う 											*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     ファイルパス名         									*/
/*	   P3		 ファイルディスクリプタ 									*/
/****************************************************************************/
#define MPCQOSCN(P1, P2, P3)			/* 特殊ファイル連結 				*/\
{																			  \
	BP_CALL_OSCONN(22, P2);				/* デバック（ブレークポイント）		*/\
	P3 = C_CONN2(P2);					/* ｏｓｃｏｎｎ発行 			M01	*/\
	BP_RETURN_OSCONN(P3);				/* デバック（ブレークポイント）		*/\
	if( P3 < 0 )						/* 返却値異常						*/\
	{																		  \
		MPCPABT(ABTLOSCN, AD_RESLT, P1, P3);								  \
										/* アボート処理（返却値異常）		*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQOSDC													*/
/*																			*/
/* ＜機能概要＞  ｏｓｄｃｏｎｎシステムコールを発行し、プロセスと特殊ファイ */
/*				 ルの連結を解除する 										*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2		 ファイルディスクリプタ 									*/
/*	   P3	     特殊ファイル情報格納域 									*/
/****************************************************************************/
#define MPCQOSDC(P1)					/* 特殊ファイル連結解除 			*/\
{																			  \
	C_DCONN2(P1);						/* ｏｓｄｃｏｎｎ発行			M01	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQREAD													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｒｅａｄｄシステムコールを発行し、ｏｓｉｒｅａｄｄ完 */
/*				 了ＩＲＢを登録する 										*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ｏｓｉｒｅａｄｄ完了ＩＲＢポインタ 						*/
/*	   P4		 ｏｓｉｒｅａｄｄの出力域へのポインタ						*/
/*	   P5		 ｏｓｉｒｅａｄｄの出力のサイズ 							*/
/****************************************************************************/
#define MPCQREAD(P1, P2, P3, P4, P5)	/* ｏｓｉｒｅａｄｄ発行処理 		*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	ARG_PRM	prm;						/* ｏｓｉｒｅａｄｄの動作パラメータ */\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	prm.sesno = P2->lsno;				/* 動作パラメータのローカルセッショ */\
										/* ン番号 を設定					*/\
	prm.option = 0x0000; 				/* 動作パラメータのオプションを設定 */\
	DELAY_READD(30);						/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IREADD2(0L, nvtppt->fildes, (char *)P4, (long)P5, prm);			  \
										/* ｏｓｉｒｅａｄｄ発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLREAD, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CREAD ,_SIR_NULL, _ML_CREAD, P2, rd); 				  \
										/* ｏｓｉｒｅａｄｄ完了ＩＲＢ発信	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQROOB													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＲＣＶＯＯＢ）システムコールを発行し、	*/
/*				 ＲＣＶＯＯＢ完了ＩＲＢを登録する							*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＲＣＶＯＯＢ完了ＩＲＢポインタ 							*/
/****************************************************************************/
#define MPCQROOB(P1, P2, P3, P4, P5)	/* ＲＣＶＯＯＢ発行処理 			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_ROOB *arg_roob; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_roob = (ARG_ROOB *)P4;			/* アーギュメント域先頭アドレス設定 */\
	arg_roob->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_roob->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_roob->optoob = 0x0000;			/* 緊急データオプション設定 		*/\
	DELAY_RCVOOB(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_RCVOOB, arg_roob, (long)P5);		  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLROOB, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CROOB ,_SIR_NULL, _ML_CROOB, P2, rd); 				  \
										/* ＲＣＶＯＯＢ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSFLG													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＮＥＴＣＴＬ：ネットワークフラグ登録）シ */
/*				 ステムコールを発行し、ＮＥＴＣＴＬ（ネットワークフラグ登録 */
/*				 ）完了ＩＲＢを登録する 									*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＮＥＴＣＴＬ（ネットワークフラグ登録）完了ＩＲＢポインタ 	*/
/*	   P4	     ネットワークフラグ											*/
/****************************************************************************/
#define MPCQSFLG(P1, P2, P3, P4)		/* ＮＥＴＣＴＬ（ネットワークフラグ */\
										/* 登録）発行処理 					*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_NETF *arg_netf; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_netf = (ARG_NETF *)((MPCLMB *)P2)->argarea; 						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_netf->cmd = NTSIFNETFLAG;		/* コマンド設定 					*/\
	arg_netf->flag.rdev = P2->rdev;		/* 装置識別子設定					*/\
	arg_netf->flag.reserve0[0] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netf->flag.reserve0[1] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netf->flag.reserve0[2] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netf->flag.netflags = P4;		/* ネットワークフラグ設定 			*/\
	arg_netf->flag.reserve1[0] = 0;		/* リザーブ（２）に０設定			*/\
	arg_netf->flag.reserve1[1] = 0;		/* リザーブ（２）に０設定			*/\
	arg_netf->flag.reserve1[2] = 0;		/* リザーブ（２）に０設定			*/\
	BP_ARGDUMP_SETNETMASK(sizeof(ARG_NETF), arg_netf, 						  \
		"NETCTL(SET NETWORKFLAG)");											  \
	DELAY_SETNFLAG(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_NETCTL, (char *)arg_netf,		      \
		(long)sizeof(ARG_NETF));										      \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLSFLG, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_LSFLG ,_SIR_NULL, _ML_LSFLG, P2, rd); 				  \
										/* ＮＥＴＣＴＬ（ネットワークフラグ */\
										/* 登録）完了ＩＲＢ発信				*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSIPA													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＮＥＴＣＴＬ：ローカルアドレス登録）シス */
/*				 テムコールを発行し、ＮＥＴＣＴＬ（ローカルアドレス登録）完 */
/*				 了ＩＲＢを登録する 										*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＮＥＴＣＴＬ（ローカルアドレス登録）完了ＩＲＢポインタ 	*/
/*	   P4	     ローカルアドレス（ＩＰアドレス）							*/
/****************************************************************************/
#define MPCQSIPA(P1, P2, P3, P4)		/* ＮＥＴＣＴＬ（ローカルアドレス登 */\
										/* 録）発行処理 					*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_NETC *arg_netc; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_netc = (ARG_NETC *)((MPCLMB *)P2)->argarea; 						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_netc->cmd = NTSIFADDR;			/* コマンド設定 					*/\
	arg_netc->addr.rdev = P2->rdev;		/* 装置識別子設定					*/\
	arg_netc->addr.reserve0[0] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.reserve0[1] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.reserve0[2] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.a_family = AF_INET;	/* アドレスファミリー識別子設定 	*/\
	arg_netc->addr.reserve1 = 0; 		/* リザーブ（１）に０設定			*/\
	arg_netc->addr.address = P4;		/* ローカルインタネットアドレス設定 */\
	arg_netc->addr.reserve2[0] = 0;		/* リザーブ（２）に０設定			*/\
	arg_netc->addr.reserve2[1] = 0;		/* リザーブ（２）に０設定			*/\
	BP_ARGDUMP_SETLOCALADDR(sizeof(ARG_NETC), arg_netc, 					  \
		"NETCTL(SET LOCALADDR)");											  \
	DELAY_SETIPADDR(30);				/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_NETCTL, (char *)arg_netc, 			  \
		(long)sizeof(ARG_NETC));											  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	BP_RETURN_SETLOCALADDR(rd);			/* ﾃﾞﾊﾞｯｸ文(RDにパッチをあてる)		*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLSIPA, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_LSIPA ,_SIR_NULL, _ML_LSIPA, P2, rd); 				  \
										/* ＮＥＴＣＴＬ（ローカルアドレス登 */\
										/* 録）完了ＩＲＢ発信				*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSMSK													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＮＥＴＣＴＬ：サブネットマスク登録）シス */
/*				 テムコールを発行し、ＮＥＴＣＴＬ（サブネットマスク登録）完 */
/*				 了ＩＲＢを登録する 										*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＮＥＴＣＴＬ（サブネットマスク登録）完了ＩＲＢポインタ 	*/
/*	   P4	     サブネットマスク											*/
/****************************************************************************/
#define MPCQSMSK(P1, P2, P3, P4)		/* ＮＥＴＣＴＬ（サブネットマスク登 */\
										/* 録）発行処理 					*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_NETC *arg_netc; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_netc = (ARG_NETC *)((MPCLMB *)P2)->argarea; 						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_netc->cmd = NTSIFNETMASK;		/* コマンド設定 					*/\
	arg_netc->addr.rdev = P2->rdev;		/* 装置識別子設定					*/\
	arg_netc->addr.reserve0[0] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.reserve0[1] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.reserve0[2] = 0;		/* リザーブ（０）に０設定			*/\
	arg_netc->addr.a_family = AF_INET;	/* アドレスファミリー識別子設定 	*/\
	arg_netc->addr.reserve1 = 0; 		/* リザーブ（１）に０設定			*/\
	arg_netc->addr.address = P4;		/* サブネットマスク設定 			*/\
	arg_netc->addr.reserve2[0] = 0;		/* リザーブ（２）に０設定			*/\
	arg_netc->addr.reserve2[1] = 0;		/* リザーブ（２）に０設定			*/\
	BP_ARGDUMP_SETNETMASK(sizeof(ARG_NETC), arg_netc, 						  \
		"NETCTL(SET SUBNETMASK)");											  \
	DELAY_SETSUBMASK(30);				/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_NETCTL, (char *)arg_netc,		      \
		(long)sizeof(ARG_NETC));										      \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLSMSK, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_LSMSK ,_SIR_NULL, _ML_LSMSK, P2, rd); 				  \
										/* ＮＥＴＣＴＬ（サブネットマスク登 */\
										/* 録）完了ＩＲＢ発信				*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSNMP													*/
/*																			*/
/* ＜機能概要＞  プールバッファ上のメッセージを送信する 					*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     送信先のメールボックスＩＤ 								*/
/*	   P3	     送信するメッセージサイズ									*/
/*	   P4	     送信するメッセージを格納するプールバッファの先頭アドレス	*/
/****************************************************************************/
#define MPCQSNMP(P1, P2, P3, P4)		/* メッセージ送信処理				*/\
{																			  \
	long	ret;						/* 返却値							*/\
	ret = C_SENMSP(P2, P3, P4); 		/* プールバッファ上のメッセージ送信 */\
	if( ret < R_NORMAL )				/* 返却値異常						*/\
	{																		  \
		MPCPABT(ABTLSNMP, AD_RESLT, P1, ret);								  \
										/* アボート処理（システムコール返却	*/\
										/* 値異常）							*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSOOB													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＳＥＮＤＯＯＢ）システムコールを発行し、 */
/*				 ＳＥＮＤＯＯＢ完了ＩＲＢを登録する 						*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＳＥＮＤＯＯＢ完了ＩＲＢポインタ							*/
/*	   P4		 送信する緊急データの格納域の先頭アドレス					*/
/*	   P5		 送信する緊急データの格納域のサイズ							*/
/****************************************************************************/
#define MPCQSOOB(P1, P2, P3, P4, P5)	/* ＳＥＮＤＯＯＢ発行処理			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_SOOB *arg_soob; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_soob = (ARG_SOOB *)P4;			/* アーギュメント域先頭アドレス設定 */\
	arg_soob->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_soob->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_soob->oob_size = P5 - sizeof(ARG_SOOB); 							  \
										/* 緊急データサイズ設定 			*/\
	arg_soob->reserve0 = 0; 			/* リザーブに０設定 				*/\
	DELAY_SENDOOB(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_SNDOOB, arg_soob, (long)P5);		  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLSOOB, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CSOOB ,_SIR_NULL, _ML_CSOOB, P2, rd); 				  \
										/* ＳＥＮＤＯＯＢ完了ＩＲＢ発信 	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQSOPT													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｉｏｃｔｌ（ＳＥＴＯＰＴ）システムコールを発行し、	*/
/*				 ＳＥＴＯＰＴ完了ＩＲＢを登録する							*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ＳＥＴＯＰＴ完了ＩＲＢポインタ 							*/
/*	   P4		 オプション種別 											*/
/*	   P5		 オプション処理種別 										*/
/*	   P6		 オプションデータ											*/
/****************************************************************************/
#define MPCQSOPT(P1, P2, P3, P4, P5, P6)/* ＳＥＴＯＰＴ発行処理０			*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_SOPT *arg_sopt; 				/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	arg_sopt = (ARG_SOPT *)((MPCIRB1 *)P3)->argarea;						  \
										/* アーギュメント域先頭アドレス設定 */\
	arg_sopt->proto_id = IPP_TCP;		/* プロトコル識別子設定 			*/\
	arg_sopt->sesno = P2->lsno; 		/* ローカルセッション番号設定		*/\
	arg_sopt->option = 0x01<<P4;		/* オプション種別設定				*/\
	arg_sopt->optset = P5;				/* 処理種別設定 					*/\
	arg_sopt->optval = P6;				/* データ設定						*/\
	DELAY_SETOPT(30);					/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IIOCTL2(0L, nvtppt->fildes, Q_SETOPT, arg_sopt,					  \
		arg_sopt->option & ((SO_SNDBUF|SO_RCVBUF)|SO_LINGER) ?				  \
		sizeof(ARG_SOPT) : sizeof(ARG_SOPT) - 4 );							  \
										/* ｏｓｉｉｏｃｔｌ２発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLSOPT, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CSETO ,P4, _ML_CSETO, P2, rd);						  \
										/* ＳＥＴＯＰＴ完了ＩＲＢ発信		*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCQWRTD													*/
/*																			*/
/* ＜機能概要＞  ｏｓｉｗｒｉｔｄシステムコールを発行し、ｏｓｉｗｒｉｔｄ完 */
/*				 了ＩＲＢを登録する 										*/
/* ＜仮引数＞																*/
/*	   P1	     拡張モジュールＩＤ（下２桁）								*/
/*	   P2	     コンテキストアドレス										*/
/*	   P3		 ｏｓｉｗｒｉｔｄ完了ＩＲＢポインタ 						*/
/*	   P4		 ｏｓｉｗｒｉｔｄの出力域へのポインタ						*/
/*	   P5		 ｏｓｉｗｒｉｔｄの出力のサイズ 							*/
/****************************************************************************/
#define MPCQWRTD(P1, P2, P3, P4, P5)	/* ｏｓｉｗｒｉｔｄ発行処理 		*/\
{																			  \
	long	rd; 						/* リクエストディスクリプタ 		*/\
	ARG_PRM	prm;						/* ｏｓｉｗｒｉｔｄの動作パラメータ */\
	MPCNVTP  *nvtppt;					/* ＮＶＴ個別部先頭アドレス 		*/\
	ARG_RW *argh_wrt;					/* アーギュメント域先頭アドレス 	*/\
	nvtppt = (MPCNVTP *)((long)mcsprefix+sizeof(MCSNVT));					  \
										/* ＮＶＴ個別部アドレス設定 		*/\
	argh_wrt = (ARG_RW *)P4;			/* アーギュメントヘッダー域設定 	*/\
	argh_wrt->a_family = AF_INET;		/* アドレスファミリー識別子設定 	*/\
	argh_wrt->r_port = 0;				/* リモートポート番号に０設定		*/\
	argh_wrt->r_ipaddr = 0L;			/* リモートアドレスに０設定 		*/\
	argh_wrt->reserve0[0] = 0L; 		/* リザーブに０設定 				*/\
	argh_wrt->reserve0[1] = 0L; 		/* リザーブに０設定 				*/\
	prm.sesno = P2->lsno;				/* 動作パラメータのローカルセッショ */\
										/* ン番号 を設定					*/\
	prm.option = 0x0000; 				/* 動作パラメータのオプションを設定 */\
	DELAY_WRITD(30);						/* ﾃﾞﾊﾞｯｸ(ｼｽﾃﾑｺｰﾙの発行を遅らせる)	*/\
	rd = C_IWRITD2(0L, nvtppt->fildes, (char *)P4, P5, prm); 				  \
										/* ｏｓｉｗｒｉｔｄ発行 		M01	*/\
	if( rd < 0 )						/* ｒｄ値異常						*/\
	{																		  \
		MPCPABT(ABTLWRTD, AD_SYSRD, P1, rd);								  \
										/* アボート処理（ｒｄ値異常）		*/\
	}																		  \
	RDPRINT(rd);						/* ﾃﾞﾊﾞｯｸ文（ｒｄ表示）				*/\
	MCS_SETRD(P3, _IR_CWRTD ,_SIR_NULL, _ML_CWRTD, P2, rd); 				  \
										/* ｏｓｉｗｒｉｔｄ完了ＩＲＢ発信	*/\
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCRSMQ1													*/
/*																			*/
/* ＜機能概要＞  メッセージを格納するＩＲＢをキューターミナルからデキューし */
/*				 応答する。デキューしたＩＲＢは解放する 					*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     キューポインタ 											*/
/*	   P2	     応答するメッセージ数										*/
/*	   P3		 コンテキストアドレス										*/
/*	   P4	     異常要因													*/
/****************************************************************************/
#define MPCRSMQ1(P1, P2, P3, P4)		/* メッセージキュー応答 			*/\
{																			  \
	MCSIRB *mq_irb;						/* メッセージキューからデキューした */\
										/* ＩＲＢ							*/\
	unsigned short	cnt;				/* カウンタ							*/\
	cnt = 0;							/* カウンタ←０						*/\
	while( cnt < P2 ) 					/* カウンタ＜応答するメッセージ数の	*/\
										/* 場合								*/\
	{																		  \
		MCS_HDEQ(P1, mq_irb);			/* ＩＲＢデキュー					*/\
		MPCMEDT1(((MPCIRB0 *)mq_irb)->msgp, P3);							  \
										/* 応答編集処理１					*/\
		mpc00001((MPCRQMSG *)((MPCIRB0 *)mq_irb)->msgp, P4,					  \
			((MPCIRB0 *)mq_irb)->msglen );									  \
										/* 応答処理 						*/\
		mcs_z300(mq_irb);				/* ＩＲＢ解放						*/\
		cnt++;							/* カウンタインクリメント			*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MPCTOPEN													*/
/*																			*/
/* ＜機能概要＞  回線制御に対してＴＣＰ／ＩＰオープン完了通知を登録する 	*/
/* ＜仮引数＞																*/
/*	   P1	     回線制御先頭アドレス										*/
/*	   P2	     回線数 													*/
/****************************************************************************/
#define MPCTOPEN(P1, P2)				/* ＴＣＰ／ＩＰオープン完了通知処理 */\
{																			  \
	unsigned short	i;					/* カウンタ							*/\
	MPCIRB0 *topenirb; 					/* ＴＣＰ／ＩＰオープン完了通知ＩＲ */\
										/* Ｂポインタ						*/\
	long	ctxtp;						/* ＴＣＰ／ＩＰオープン完了通知ＩＲ */\
										/* Ｂを発信するコンテキストアドレス */\
	ctxtp = P1; 						/* コンテキストアドレスに最初に発信 */\
										/* するアドレスを設定する			*/\
	i = 0;								/* カウンタ←０						*/\
	while( i < P2 )						/* カウンタ＜回線数 				*/\
	{																		  \
		topenirb = (MPCIRB0 *)mcs_z200(TYPN);								  \
										/* ＴＣＰ／ＩＰオープン完了通知ＩＲ */\
										/* Ｂ確保							*/\
		MCS_IREQ(topenirb, _IR_LOPEN, _SIR_NULL, _ML_LOPEN, ctxtp); 		  \
										/* ＴＣＰ／ＩＰオープン完了通知ＩＲ */\
										/* 信								*/\
		ctxtp += sizeof(MPCLMB);		/* コンテキストアドレスに次に発信す */\
										/* るアドレスを設定する 			*/\
		i++;							/* カウンタインクリメント			*/\
	}																		  \
}

/****************************************************************************/
/*																			*/
/* ＜マクロ名＞  MI_LSTAT													*/
/*																			*/
/* ＜機能概要＞  ＬＡＮチャネル状態を行う									*/
/*																			*/
/* ＜仮引数＞																*/
/*	   P1	     詳細情報													*/
/*	   P2	     任意値１ 													*/
/*	   P3	     モジュールＩＤ（拡張モジュールＩＤの下２桁）				*/
/****************************************************************************/
#define MI_LSTAT(P1, P2, P3) 			/* アボート処理 					*/\
	P3 = mi_lstat(P1, P2);				/* ＬＡＮチャネル状態				*/\
	BP_RETURN_MILSTAT(P3, &P3);			/* デバック文						*/
